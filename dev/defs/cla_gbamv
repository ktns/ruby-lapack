--- 
:name: cla_gbamv
:md5sum: 6fdc0ec1e9d677c211aaed9e1e36bb0c
:category: :subroutine
:arguments: 
- trans: 
    :type: integer
    :intent: input
- m: 
    :type: integer
    :intent: input
- n: 
    :type: integer
    :intent: input
- kl: 
    :type: integer
    :intent: input
- ku: 
    :type: integer
    :intent: input
- alpha: 
    :type: real
    :intent: input
- ab: 
    :type: real
    :intent: input
    :dims:
    - ldab
    - n
- ldab: 
    :type: integer
    :intent: input
- x: 
    :type: real
    :intent: input
    :dims: 
    - "((lsame_(&trans,\"N\")) || (lsame_(&trans,\"n\"))) ? 1 + ( n - 1 )*abs( incx ) : 1 + ( m - 1 )*abs( incx )"
- incx: 
    :type: integer
    :intent: input
- beta: 
    :type: real
    :intent: input
- y: 
    :type: real
    :intent: input/output
    :dims: 
    - "((lsame_(&trans,\"N\")) || (lsame_(&trans,\"n\"))) ? 1 + ( m - 1 )*abs( incy ) : 1 + ( n - 1 )*abs( incy )"
- incy: 
    :type: integer
    :intent: input
:substitutions: 
  ldab: MAX(1,m)
:fortran_help: "      SUBROUTINE CLA_GBAMV( TRANS, M, N, KL, KU, ALPHA, AB, LDAB, X, INCX, BETA, Y, INCY )\n\n\
  *  Purpose\n\
  *  =======\n\
  *\n\
  *  SLA_GBAMV  performs one of the matrix-vector operations\n\
  *\n\
  *          y := alpha*abs(A)*abs(x) + beta*abs(y),\n\
  *     or   y := alpha*abs(A)'*abs(x) + beta*abs(y),\n\
  *\n\
  *  where alpha and beta are scalars, x and y are vectors and A is an\n\
  *  m by n matrix.\n\
  *\n\
  *  This function is primarily used in calculating error bounds.\n\
  *  To protect against underflow during evaluation, components in\n\
  *  the resulting vector are perturbed away from zero by (N+1)\n\
  *  times the underflow threshold.  To prevent unnecessarily large\n\
  *  errors for block-structure embedded in general matrices,\n\
  *  \"symbolically\" zero components are not perturbed.  A zero\n\
  *  entry is considered \"symbolic\" if all multiplications involved\n\
  *  in computing that entry have at least one zero multiplicand.\n\
  *\n\n\
  *  Arguments\n\
  *  ==========\n\
  *\n\
  *  TRANS   (input) INTEGER\n\
  *           On entry, TRANS specifies the operation to be performed as\n\
  *           follows:\n\
  *\n\
  *             BLAS_NO_TRANS      y := alpha*abs(A)*abs(x) + beta*abs(y)\n\
  *             BLAS_TRANS         y := alpha*abs(A')*abs(x) + beta*abs(y)\n\
  *             BLAS_CONJ_TRANS    y := alpha*abs(A')*abs(x) + beta*abs(y)\n\
  *\n\
  *           Unchanged on exit.\n\
  *\n\
  *  M      (input) INTEGER\n\
  *           On entry, M specifies the number of rows of the matrix A.\n\
  *           M must be at least zero.\n\
  *           Unchanged on exit.\n\
  *\n\
  *  N      (input) INTEGER\n\
  *           On entry, N specifies the number of columns of the matrix A.\n\
  *           N must be at least zero.\n\
  *           Unchanged on exit.\n\
  *\n\
  *  KL     (input) INTEGER\n\
  *           The number of subdiagonals within the band of A.  KL >= 0.\n\
  *\n\
  *  KU     (input) INTEGER\n\
  *           The number of superdiagonals within the band of A.  KU >= 0.\n\
  *\n\
  *  ALPHA  (input) REAL\n\
  *           On entry, ALPHA specifies the scalar alpha.\n\
  *           Unchanged on exit.\n\
  *\n\
  *  A      (input) REAL array, dimension (LDA,n)\n\
  *           Before entry, the leading m by n part of the array A must\n\
  *           contain the matrix of coefficients.\n\
  *           Unchanged on exit.\n\
  *\n\
  *  LDA    (input) INTEGER\n\
  *           On entry, LDA specifies the first dimension of A as declared\n\
  *           in the calling (sub) program. LDA must be at least\n\
  *           max( 1, m ).\n\
  *           Unchanged on exit.\n\
  *\n\
  *  X      (input) REAL array, dimension at least\n\
  *           ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'\n\
  *           and at least\n\
  *           ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.\n\
  *           Before entry, the incremented array X must contain the\n\
  *           vector x.\n\
  *           Unchanged on exit.\n\
  *\n\
  *  INCX   (input) INTEGER\n\
  *           On entry, INCX specifies the increment for the elements of\n\
  *           X. INCX must not be zero.\n\
  *           Unchanged on exit.\n\
  *\n\
  *  BETA   (input) REAL\n\
  *           On entry, BETA specifies the scalar beta. When BETA is\n\
  *           supplied as zero then Y need not be set on input.\n\
  *           Unchanged on exit.\n\
  *\n\
  *  Y      (input/output) REAL array, dimension at least\n\
  *           ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'\n\
  *           and at least\n\
  *           ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.\n\
  *           Before entry with BETA non-zero, the incremented array Y\n\
  *           must contain the vector y. On exit, Y is overwritten by the\n\
  *           updated vector y.\n\
  *\n\
  *  INCY   (input) INTEGER\n\
  *           On entry, INCY specifies the increment for the elements of\n\
  *           Y. INCY must not be zero.\n\
  *           Unchanged on exit.\n\
  *\n\
  *\n\
  *  Level 2 Blas routine.\n\
  *\n\n\
  *  =====================================================================\n\
  *\n"
